{"name":"Exemplo do padrão Template Method em C++","tagline":"Exemplo em C++ do uso do padrão de projeto Template Method","body":"## Descrição do padrão\r\n\r\nO padrão tem a intenção de definir um esqueleto de um algoritmo em uma operação, deixando a responsabilidade da implementação para as classes filhas.\r\n\r\nA classe base declara algoritmos de base que serão implementados pelas classes derivadas.\r\n\r\n![Estrutura do padrão Template Method](http://sourcemaking.com/files/v2/content/patterns/Template_Method-2x.png)\r\n\r\nComo é possível notar, o método template chama os outros três seguintes métodos, como se fossem passos. Porém a classe base deixa para as subclasses definirem tais passos. A classe pai é uma classe abstrata, que só implementa o `templateMethod()`, logo não há o risco do cliente instanciar um `FrameworkClass` sem que os passos do algoritmos estejam implementados.\r\n\r\n## Explicação do Exemplo\r\n\r\nO exemplo trata de uma \"agenda de trabalho\" que pode ter trabalhos tanto de manutenção quanto de limpeza. Tanto para limpeza quanto para manutenção temos 4 passos a serem feitos: iniciar a tarefa, tarefa da primeira hora, da segunda hora e da terceira hora.\r\n\r\nA classe `WorkSchedule` (`FrameworkClass`) é a classe abstrata que define a interface da agenda de trabalho. Ela tem o método público `threeHourOperation()` que é utilizado pela classe cliente e os métodos protegidos (para que seja implementados, mas não visíveis para o cliente) que definem os passos do algoritmo.\r\n\r\n**WorkSchedule.h:**\r\n```cpp\r\nclass WorkSchedule\r\n{\r\npublic:\r\n    WorkSchedule();\r\n    void threeHourOperation() const;\r\n    virtual ~WorkSchedule();\r\nprotected:\r\n    virtual void startTask() const = 0;\r\n    virtual void hourOneTask() const = 0;\r\n    virtual void hourTwoTask() const = 0;\r\n    virtual void hourThreeTask() const = 0;\r\n};\r\n```\r\n\r\n**WorkSchedule.cpp:**\r\n```cpp\r\nWorkSchedule::WorkSchedule()\r\n{\r\n}\r\n\r\nvoid WorkSchedule::threeHourOperation() const\r\n{\r\n    startTask();\r\n    hourOneTask();\r\n    hourTwoTask();\r\n    hourThreeTask();\r\n}\r\n\r\nWorkSchedule::~WorkSchedule()\r\n{\r\n}\r\n```\r\n\r\nComo podemos ver apenas o método público é implementado. É interessante notar que nesse padrão acontece um caminho inverso ao que geralmente acontece, que é chamar métodos das classes filhas, que nem foram implementados ainda. Também vale notar que o método `threeHourOperation()` não pode ser implementado pelas classes filhas. Para fazer isso em Java temos que usar a palavra chave `final` na declaração do método.\r\n\r\nAs classes filhas `CleaningOperation` e `Maintence` tem uma implementação simples, apenas implementando os métodos abstratos `startTask()`, `hourOneTask()`, `hourTwoTask()` e `hourThreeTask()`.\r\n\r\n**CleaningOperation.h:**\r\n```cpp\r\nclass CleaningOperation : public WorkSchedule\r\n{\r\npublic:\r\n    CleaningOperation();\r\n    virtual ~CleaningOperation();\r\nprotected:\r\n    virtual void startTask() const;\r\n    virtual void hourOneTask() const;\r\n    virtual void hourTwoTask() const;\r\n    virtual void hourThreeTask() const;\r\n};\r\n```\r\n\r\n**CleaningOperation.cpp:**\r\n```cpp\r\nCleaningOperation::CleaningOperation()\r\n{\r\n}\r\n\r\nvoid CleaningOperation::startTask() const\r\n{\r\n    cout << \"Cleaning operation started.\" << endl;\r\n}\r\n\r\nvoid CleaningOperation::hourOneTask() const\r\n{\r\n    cout << \"Cleaning step 1.\" << endl;\r\n}\r\n\r\nvoid CleaningOperation::hourTwoTask() const\r\n{\r\n    cout << \"Cleaning step 2.\" << endl;\r\n}\r\n\r\nvoid CleaningOperation::hourThreeTask() const\r\n{\r\n    cout << \"Cleaning step 3.\" << endl;\r\n}\r\n\r\nCleaningOperation::~CleaningOperation()\r\n{\r\n}\r\n```\r\n\r\n**Maintence.h:**\r\n```cpp\r\nclass Maintence : public WorkSchedule\r\n{\r\npublic:\r\n    Maintence();\r\n    virtual ~Maintence();\r\nprotected:\r\n    virtual void startTask() const;\r\n    virtual void hourOneTask() const;\r\n    virtual void hourTwoTask() const;\r\n    virtual void hourThreeTask() const;\r\n};\r\n```\r\n\r\n**Maintence.cpp:**\r\n```cpp\r\nMaintence::Maintence()\r\n{\r\n}\r\n\r\nvoid Maintence::startTask() const\r\n{\r\n    cout << \"Maintence task started.\" << endl;\r\n}\r\n\r\nvoid Maintence::hourOneTask() const\r\n{\r\n    cout << \"Maintence step 1.\" << endl;\r\n}\r\n\r\nvoid Maintence::hourTwoTask() const\r\n{\r\n    cout << \"Maintence step 2.\" << endl;\r\n}\r\n\r\nvoid Maintence::hourThreeTask() const\r\n{\r\n    cout << \"Maintence step 3.\" << endl;\r\n}\r\n\r\nMaintence::~Maintence()\r\n{\r\n}\r\n```\r\n\r\nDessa forma o cliente apenas precisa instanciar uma implementação de `WorkSchedule` para utilizar a classe.\r\n\r\n**main.cpp(cliente):**\r\n```cpp\r\nint main(int argc, char** argv)\r\n{\r\n    const WorkSchedule * const cleaningWork = new CleaningOperation;\r\n    const WorkSchedule * const maintence = new Maintence;\r\n\r\n    cleaningWork->threeHourOperation();\r\n    maintence->threeHourOperation();\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n## Alunos\r\n - Lucas Possatti (@possatti)\r\n - Phillipe Alcantara (@paflopes)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}